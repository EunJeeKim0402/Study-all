Context Switching(문맥 교환)
    현재 실행되고 있던 프로세스/쓰레드의 상태를 저장하고 CPU를 다른 프로세스/쓰레드에게 넘겨주는 것.
        * CPU가 해당 프로세스를 실행하기 위한 정보들을 컨텍스트라고 함.
    CPU에 실행할 프로세스를 교체하는 기술
    여러 프로세스/쓰레드를 동시에 실행시키기 위해 필요

HTTP(Hypertext Transfer Protocol)
    텍스트 기반 통신 규약. 인터넷에서 데이터를 주고받을 수 있는 프로토콜.
    클라이언트-서버구조를 따르며 TCP/IP위에서 작동함.

뷰(View)
    물리적 테이블을 근거한 논리적인 가상 테이블.
    테이블에는 데이터가 있지만 뷰에는 없고 SQL만 저장되어있음.
    JOIN문 사용의 최소화로 사용상의 편의성을 최대화함.

Equals()와 Hashcode()
    모든 Java객체의 부모객체인 Object클래스에 정의되어있음. 따라서 Java의 모든 객체는 두 함수를 상속.
    == 연산자 : primitive type은 값 비교, reference Type은 객체의 주소값을 비교
        * primitive type(원시타입) : 기본적인 데이터 타입. 빈 객체 타입으로 null을 가질 수 없고 stack메모리 저장
        * reference type(참조타입) : 객체를 가리키는 참조(메모리주소)를 저장하는 데이터타입. null가능, heap메모리에 생성
        
Spring MVC / Spring Boot
    스프링 프레임워크의 핵심모듈. MVC패턴을 통해 명확한 역할 분리를통해 계층관리&유지보수성 높임.
    * DispatcherServlet : 모든 HTTP 요청을 중앙에서 처리하는 Front Controller. 모든 요청을 받아 적절한 핸들러를 반환, View로 응답.
    * HandlerMapping : 어떤 컨트롤러가 요청을 처리할지 결정. url패턴과 컨트롤러 매소드를 맵핑.
    * Controller : 실제 비즈니스 로직 처리
    * ViewResolver : 논리적인 View이름을 실제 View객체로 변환해서 반환. JSP등의 템플릿엔진과 통합하여 View를 랜더링.
    Spring Boot란 애플리케이션의 복잡한 설정을 자동화함. 자동설정, 여러 스타터Dependincies제공, 독립 실행형 애플리케이션.

프로세스 스케줄링 알고리즘
    CPU스케줄링 : 언제 어떤 프로세스에게 CPU를 할당할지 결정하는 작업.
    * 공평성을 고려한 방식
        FCFS(First-Come-First-Service) : 선착순
        RR(Round-Robin) : 제한시간을 두는 방식
    * 시스템 성능과 효율성 고려 방식(실행시간 예측 부하의 문제가 있음)
        SJF(Shor-Job-First) : 실행시간이 짧은 순서대로 할당(선점형SJF가 SPN/비선점형 SJF가 SRTN)
            SPN(Shortest-Process-Next) : 짧은 BT를 우선으로 처리하는 방식
            SRTN(Shortest-Remaing-Time-Next) : 남은 시간이 짧은 것을 우선으로 처리
        HRRN(High-Response-Ratio-Next) : RR이 적은 것을 우선으로 처리
    * BT(실행시간) 예측 문제를 개선한 방식
        MLQ(Multi-level-Queue) : 여러개의 레디큐를 두는 방식
        MFQ(Multi-level-Feedback-Queue) : MLQ와 동일한 방식에서 queue를 다이나믹하게 운용하는 방식

HTTP 버전 비교
    HTTP 1.0 : 첫번째 버전. 요청파이프라인 지원이 부족하여 클라이언트가 다음 요청 보내기 전에 응답 기다려야됨.
               비지속적 연결 사용. 이는 각 요청/응답 교환에 대해 매번 사로운 TCP연결이 설정되었음을 의미함.
               대용량파일을 효율적으로 처리하기위한 메커니즘이 포함되지 않아 여러 리소스가있는 웹페이지 로딩 느림.
    HTTP 1.1 : 여러 요청/응답에 대해 단일 TCP연결을 재사용하여 대기시간을 줄이기위해 지속적인 연결을 도입.
               호스트헤더는 필수항목이 됨. 가상호스팅 활성화/동일 IP주소에서 여러 웹사이트 허용. 캐싱 메커니즘 향상.
               * 호스트 헤더 : HTTP요청의 일부이며, 웹서버에게 요청을 보낼 때 해당 요청이 어떤 도메인 리소스 타깃인지 알려줌.
                              이를 통해 하나의 IP주소에서 여러개의 도메인 이름을 가진 웹사이트를 동시에 호스팅 가능.
    1.0 VS 1.1 - 지속성 : 1.0은 요청하고 수신할때마다 새로운 TCP세션을 맺고, 1.1은 한번만 맺으면 여러개의 요청을 보내고 응답 수신 가능.
                 파이프라이닝 : 1.0은 요청에 대한 응답이 와야 다음 응답 보내기 가능. 1.1은 요청을 병렬로 처리 가능.
                 호스트 헤더 : 1.0은 하나의 IP에 하나의 도메인만 운영 가능. 1.1은 웹서버에 요청 Header에 Host를 전달받아
                              서버로 보내주는 가상호스팅이 가능. 즉 서버 1대가 여러개의 호스트 담당 가능.
    HTTP 2.0 : 다중화 지원. 단일 연결을 통해 동시에 여러 요청/응답 보내기 가능.
               헤더 압축을 사용하여 요청 및 응답 헤더의 크기를 줄여 대역폭 활용도를 높임.
    1.1 VS 2.0 - 다중화 : 2.0에서는 1개의 세션으로 여러개의 요청을 순서 상관없이 받아서 동시다발적으로 처리/응답.
                        따라서 1.1의 HOLB(Head Of Line Blocking)문제를 해결하게됨.
                 스트림우선순위지정 : 2.0에서는 각 요청에 우선순위 부여. 예를들어 html과 image에서는 html을 먼저 응답.
                 서버푸쉬 : 2.0부터는 html문서를 요청하면 클라이언트가 요청하지않아도 서버가 필요한 리소스를 알아서 보냄.
                 헤더압축 : 1.1에서는 이전에 보냈던 요청과 중복되는 헤더도 똑같이 전송하느라 자원낭비.
                           2.0부터는 허프만코딩을 사용한 HPACK압축방식으로 이를 개선.
                           클라이언트와 서버는 각각 헤더 테이블을 관리/이전요청과 동일한 필드는 table index만 보냄.
    HTTP 3.0 : 2.0으로 성능이 좋아졌으나 TCP기반 위에서 동작하니 핸드쉐이크과정에서의 지연시간/패킷유실/오류시 패킷재전송 HOL발생.
               전송 레이어에 TCP가 아닌 UDP기반인 QUIC(Quick UDP Internet Connections) 프로토콜 사용.
               UDP(User Datagram Protocol)은 데이터그램 방식을 사용하는 프로토콜. 패킷의 목적지만 정해지면 중간경로 신경안씀.
    * HOL(Head-of-line)

함수적 종속성과 정규화
    DB정규화 : 데이터 중복과 삽입/수정/이상현상을 최소화하기위해 일련의 정규형에따라 관계형 DB를 구성하는 과정.
               일반적으로 3NF까지 도달하면 정규화 성립.
    함수적 종속성 : Functional Dependency. 테이블에 있는 두개의 속성들 사이의 제약을 말함.
                  예시로 테이블 R에 존재하는 필드의 부분집합을 각각 X/Y라했을 때 X의 한 값이 Y에 속한 하나의 값에만
                  매핑되는 경우 Y는 X함수종속적이다 라고하며 X -> Y로 표기함.
    정규화 - 제1정규형 : 한 릴레이션을 구성하는 모든 도메인이 원자값으로 된 정류형(속성의 원자화)
            제2정규형 : 제1정규형을 만족하면서 릴레이션에 존재하는 부분함수적종속을 제거하여, 모든 속성이 기본키에 완전
                        함수 종속이 되도록 만들어진 정규형.
            제3정규형 : 제2정규형을 만족하면서 릴레이션을 구성하는 속성들 간의 이행적 종속 관계를 분해하여,
                        속성들이 비이행적 함수 종속 관계를 만족하도록 만들어진 정규형.
            보이스-코드 정규형 : 제2정규형을 만족하면서 릴레이션의 모든 결정자가 후보키가 되도록하는 정규형.

Colletion
    List : 데이터의 저장 순서가 유지되고 중복을 허용함(구현클래스 : ArrayList, LinkedList)
        ArrayList : Object배열을 사용해서 데이터를 순차적으로 저장. 배열크기 변경 불가.
        LinkedList : 이중연결리스트로 구현되어있음. 배열과 달리 불연속적으로 존재하는 데이터를 연결.
    Set : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복 불허(구현클래스 : HashSet, TreeSet)
        HashSet : 저장순서 유지X(정렬도 불가).
        TreeSet : Binary Search Tree로 구현되어있음. 범위검색과 정렬에 유리함. 위보다 데이터 추가/삭제에 시간이 더걸림.
    Map : key-value형식으로 데이터를 저장하는 자료구조. key는 유니크, value는 중복 가능.
        TreeMap : Binary Search Tree로 구현되어있음. 범위검색과 정렬에 유리.

AOP(Aspect-Oriented Programming)
    객체지향프로그래밍(OOP) : 하나의 부가 기능을 여러 곳에서 동일하게 사용.
    관점지향프로그래밍(AOP) : 메소드나 객체의 기능을 핵심관심사/공통관심사로 나누어 프로그래밍.